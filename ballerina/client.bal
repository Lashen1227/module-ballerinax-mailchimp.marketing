// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

// Copyright (c) 2025, WSO2 LLC. (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/data.jsondata;
import ballerina/http;

public isolated client class Client {
    final http:Client clientEp;
    # Gets invoked to initialize the `connector`.
    #
    # + config - The configurations to be used when initializing the `connector` 
    # + serviceUrl - URL of the target service 
    # + return - An error if connector initialization failed 
    public isolated function init(ConnectionConfig config, string serviceUrl = "https://server.api.mailchimp.com/3.0") returns error? {
        http:ClientConfiguration httpClientConfig = {auth: config.auth, httpVersion: config.httpVersion, http1Settings: config.http1Settings, http2Settings: config.http2Settings, timeout: config.timeout, forwarded: config.forwarded, followRedirects: config.followRedirects, poolConfig: config.poolConfig, cache: config.cache, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, cookieConfig: config.cookieConfig, responseLimits: config.responseLimits, secureSocket: config.secureSocket, proxy: config.proxy, socketConfig: config.socketConfig, validation: config.validation, laxDataBinding: config.laxDataBinding};
        self.clientEp = check new (serviceUrl, httpClientConfig);
    }

    # List api root resources
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get .(map<string|string[]> headers = {}, *GetRootQueries queries) returns APIRoot|error {
        string resourcePath = string `/`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get latest chimp chatter
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - ChimpChatter Collection 
    resource isolated function get activity\-feed/chimp\-chatter(map<string|string[]> headers = {}, *GetActivityFeedChimpChatterQueries queries) returns InlineResponse200|error {
        string resourcePath = string `/activity-feed/chimp-chatter`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # List account exports
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get account\-exports(map<string|string[]> headers = {}, *GetAccountExportsQueries queries) returns InlineResponse2001|error {
        string resourcePath = string `/account-exports`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add export
    #
    # + headers - Headers to be sent with the request 
    resource isolated function post account\-exports(CreateAnAccountExport payload, map<string|string[]> headers = {}) returns InlineResponse2002|error {
        string resourcePath = string `/account-exports`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get account export info
    #
    # + exportId - The unique id for the account export
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get account\-exports/[string exportId](map<string|string[]> headers = {}, *GetAccountExportIdQueries queries) returns InlineResponse2002|error {
        string resourcePath = string `/account-exports/${getEncodedUri(exportId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List authorized apps
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get authorized\-apps(map<string|string[]> headers = {}, *GetAuthorizedAppsQueries queries) returns InlineResponse2003|error {
        string resourcePath = string `/authorized-apps`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get authorized app info
    #
    # + appId - The unique id for the connected authorized application
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get authorized\-apps/[string appId](map<string|string[]> headers = {}, *GetAuthorizedAppsIdQueries queries) returns InlineResponse2004|error {
        string resourcePath = string `/authorized-apps/${getEncodedUri(appId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List automations
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get automations(map<string|string[]> headers = {}, *GetAutomationsQueries queries) returns InlineResponse2005|error {
        string resourcePath = string `/automations`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add automation
    #
    # + headers - Headers to be sent with the request 
    resource isolated function post automations(AutomationWorkflow payload, map<string|string[]> headers = {}) returns AutomationWorkflow1|error {
        string resourcePath = string `/automations`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get automation info
    #
    # + workflowId - The unique id for the Automation workflow
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get automations/[string workflowId](map<string|string[]> headers = {}, *GetAutomationsIdQueries queries) returns AutomationWorkflow1|error {
        string resourcePath = string `/automations/${getEncodedUri(workflowId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Pause automation emails
    #
    # + workflowId - The unique id for the Automation workflow
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function post automations/[string workflowId]/actions/pause\-all\-emails(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/automations/${getEncodedUri(workflowId)}/actions/pause-all-emails`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Start automation emails
    #
    # + workflowId - The unique id for the Automation workflow
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function post automations/[string workflowId]/actions/start\-all\-emails(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/automations/${getEncodedUri(workflowId)}/actions/start-all-emails`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Archive automation
    #
    # + workflowId - The unique id for the Automation workflow
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function post automations/[string workflowId]/actions/archive(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/automations/${getEncodedUri(workflowId)}/actions/archive`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # List automated emails
    #
    # + workflowId - The unique id for the Automation workflow
    # + headers - Headers to be sent with the request 
    resource isolated function get automations/[string workflowId]/emails(map<string|string[]> headers = {}) returns AutomationEmails|error {
        string resourcePath = string `/automations/${getEncodedUri(workflowId)}/emails`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get workflow email info
    #
    # + workflowId - The unique id for the Automation workflow
    # + workflowEmailId - The unique id for the Automation workflow email
    # + headers - Headers to be sent with the request 
    resource isolated function get automations/[string workflowId]/emails/[string workflowEmailId](map<string|string[]> headers = {}) returns AutomationWorkflowEmail|error {
        string resourcePath = string `/automations/${getEncodedUri(workflowId)}/emails/${getEncodedUri(workflowEmailId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete workflow email
    #
    # + workflowId - The unique id for the Automation workflow
    # + workflowEmailId - The unique id for the Automation workflow email
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete automations/[string workflowId]/emails/[string workflowEmailId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/automations/${getEncodedUri(workflowId)}/emails/${getEncodedUri(workflowEmailId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update workflow email
    #
    # + workflowId - The unique id for the Automation workflow
    # + workflowEmailId - The unique id for the Automation workflow email
    # + headers - Headers to be sent with the request 
    resource isolated function patch automations/[string workflowId]/emails/[string workflowEmailId](UpdateInformationAboutASpecificWorkflowEmail payload, map<string|string[]> headers = {}) returns AutomationWorkflowEmail|error {
        string resourcePath = string `/automations/${getEncodedUri(workflowId)}/emails/${getEncodedUri(workflowEmailId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # List automated email subscribers
    #
    # + workflowId - The unique id for the Automation workflow
    # + workflowEmailId - The unique id for the Automation workflow email
    # + headers - Headers to be sent with the request 
    resource isolated function get automations/[string workflowId]/emails/[string workflowEmailId]/queue(map<string|string[]> headers = {}) returns InlineResponse2006|error {
        string resourcePath = string `/automations/${getEncodedUri(workflowId)}/emails/${getEncodedUri(workflowEmailId)}/queue`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Add subscriber to workflow email
    #
    # + workflowId - The unique id for the Automation workflow
    # + workflowEmailId - The unique id for the Automation workflow email
    # + headers - Headers to be sent with the request 
    resource isolated function post automations/[string workflowId]/emails/[string workflowEmailId]/queue(SubscriberInAutomationQueue payload, map<string|string[]> headers = {}) returns SubscriberInAutomationQueue1|error {
        string resourcePath = string `/automations/${getEncodedUri(workflowId)}/emails/${getEncodedUri(workflowEmailId)}/queue`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get automated email subscriber
    #
    # + workflowId - The unique id for the Automation workflow
    # + workflowEmailId - The unique id for the Automation workflow email
    # + subscriberHash - The MD5 hash of the lowercase version of the list member's email address
    # + headers - Headers to be sent with the request 
    resource isolated function get automations/[string workflowId]/emails/[string workflowEmailId]/queue/[string subscriberHash](map<string|string[]> headers = {}) returns SubscriberInAutomationQueue1|error {
        string resourcePath = string `/automations/${getEncodedUri(workflowId)}/emails/${getEncodedUri(workflowEmailId)}/queue/${getEncodedUri(subscriberHash)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Pause automated email
    #
    # + workflowId - The unique id for the Automation workflow
    # + workflowEmailId - The unique id for the Automation workflow email
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function post automations/[string workflowId]/emails/[string workflowEmailId]/actions/pause(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/automations/${getEncodedUri(workflowId)}/emails/${getEncodedUri(workflowEmailId)}/actions/pause`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Start automated email
    #
    # + workflowId - The unique id for the Automation workflow
    # + workflowEmailId - The unique id for the Automation workflow email
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function post automations/[string workflowId]/emails/[string workflowEmailId]/actions/'start(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/automations/${getEncodedUri(workflowId)}/emails/${getEncodedUri(workflowEmailId)}/actions/start`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # List subscribers removed from workflow
    #
    # + workflowId - The unique id for the Automation workflow
    # + headers - Headers to be sent with the request 
    resource isolated function get automations/[string workflowId]/removed\-subscribers(map<string|string[]> headers = {}) returns RemovedSubscribers|error {
        string resourcePath = string `/automations/${getEncodedUri(workflowId)}/removed-subscribers`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Remove subscriber from workflow
    #
    # + workflowId - The unique id for the Automation workflow
    # + headers - Headers to be sent with the request 
    resource isolated function post automations/[string workflowId]/removed\-subscribers(SubscriberInAutomationQueue payload, map<string|string[]> headers = {}) returns SubscriberRemovedFromAutomationWorkflow|error {
        string resourcePath = string `/automations/${getEncodedUri(workflowId)}/removed-subscribers`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get subscriber removed from workflow
    #
    # + workflowId - The unique id for the Automation workflow
    # + subscriberHash - The MD5 hash of the lowercase version of the list member's email address
    # + headers - Headers to be sent with the request 
    resource isolated function get automations/[string workflowId]/removed\-subscribers/[string subscriberHash](map<string|string[]> headers = {}) returns SubscriberRemovedFromAutomationWorkflow|error {
        string resourcePath = string `/automations/${getEncodedUri(workflowId)}/removed-subscribers/${getEncodedUri(subscriberHash)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # List batch requests
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get batches(map<string|string[]> headers = {}, *GetBatchesQueries queries) returns BatchOperations|error {
        string resourcePath = string `/batches`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Start batch operation
    #
    # + headers - Headers to be sent with the request 
    resource isolated function post batches(BatchesBody payload, map<string|string[]> headers = {}) returns Batch|error {
        string resourcePath = string `/batches`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get batch operation status
    #
    # + batchId - The unique id for the batch operation
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get batches/[string batchId](map<string|string[]> headers = {}, *GetBatchesIdQueries queries) returns Batch|error {
        string resourcePath = string `/batches/${getEncodedUri(batchId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete batch request
    #
    # + batchId - The unique id for the batch operation
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete batches/[string batchId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/batches/${getEncodedUri(batchId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # List batch webhooks
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get batch\-webhooks(map<string|string[]> headers = {}, *GetBatchWebhooksQueries queries) returns BatchWebhooks|error {
        string resourcePath = string `/batch-webhooks`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add batch webhook
    #
    # + headers - Headers to be sent with the request 
    resource isolated function post batch\-webhooks(BatchWebhook payload, map<string|string[]> headers = {}) returns BatchWebhook1|error {
        string resourcePath = string `/batch-webhooks`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get batch webhook info
    #
    # + batchWebhookId - The unique id for the batch webhook
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get batch\-webhooks/[string batchWebhookId](map<string|string[]> headers = {}, *GetBatchWebhookQueries queries) returns BatchWebhook1|error {
        string resourcePath = string `/batch-webhooks/${getEncodedUri(batchWebhookId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete batch webhook
    #
    # + batchWebhookId - The unique id for the batch webhook
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete batch\-webhooks/[string batchWebhookId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/batch-webhooks/${getEncodedUri(batchWebhookId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update batch webhook
    #
    # + batchWebhookId - The unique id for the batch webhook
    # + headers - Headers to be sent with the request 
    resource isolated function patch batch\-webhooks/[string batchWebhookId](BatchWebhook2 payload, map<string|string[]> headers = {}) returns BatchWebhook1|error {
        string resourcePath = string `/batch-webhooks/${getEncodedUri(batchWebhookId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # List template folders
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get template\-folders(map<string|string[]> headers = {}, *GetTemplateFoldersQueries queries) returns TemplateFolders|error {
        string resourcePath = string `/template-folders`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add template folder
    #
    # + headers - Headers to be sent with the request 
    resource isolated function post template\-folders(TemplateFolder payload, map<string|string[]> headers = {}) returns TemplateFolder1|error {
        string resourcePath = string `/template-folders`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get template folder
    #
    # + folderId - The unique id for the template folder
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get template\-folders/[string folderId](map<string|string[]> headers = {}, *GetTemplateFoldersIdQueries queries) returns TemplateFolder1|error {
        string resourcePath = string `/template-folders/${getEncodedUri(folderId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete template folder
    #
    # + folderId - The unique id for the template folder
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete template\-folders/[string folderId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/template-folders/${getEncodedUri(folderId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update template folder
    #
    # + folderId - The unique id for the template folder
    # + headers - Headers to be sent with the request 
    resource isolated function patch template\-folders/[string folderId](TemplateFolder payload, map<string|string[]> headers = {}) returns TemplateFolder1|error {
        string resourcePath = string `/template-folders/${getEncodedUri(folderId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # List campaign folders
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get campaign\-folders(map<string|string[]> headers = {}, *GetCampaignFoldersQueries queries) returns CampaignFolders|error {
        string resourcePath = string `/campaign-folders`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add campaign folder
    #
    # + headers - Headers to be sent with the request 
    resource isolated function post campaign\-folders(CampaignFolder payload, map<string|string[]> headers = {}) returns CampaignFolder1|error {
        string resourcePath = string `/campaign-folders`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get campaign folder
    #
    # + folderId - The unique id for the campaign folder
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get campaign\-folders/[string folderId](map<string|string[]> headers = {}, *GetCampaignFoldersIdQueries queries) returns CampaignFolder1|error {
        string resourcePath = string `/campaign-folders/${getEncodedUri(folderId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete campaign folder
    #
    # + folderId - The unique id for the campaign folder
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete campaign\-folders/[string folderId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/campaign-folders/${getEncodedUri(folderId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update campaign folder
    #
    # + folderId - The unique id for the campaign folder
    # + headers - Headers to be sent with the request 
    resource isolated function patch campaign\-folders/[string folderId](CampaignFolder payload, map<string|string[]> headers = {}) returns CampaignFolder1|error {
        string resourcePath = string `/campaign-folders/${getEncodedUri(folderId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # List campaigns
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get campaigns(map<string|string[]> headers = {}, *GetCampaignsQueries queries) returns InlineResponse2007|error {
        string resourcePath = string `/campaigns`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add campaign
    #
    # + headers - Headers to be sent with the request 
    resource isolated function post campaigns(Campaign payload, map<string|string[]> headers = {}) returns Campaign1|error {
        string resourcePath = string `/campaigns`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get campaign info
    #
    # + campaignId - The unique id for the campaign
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get campaigns/[string campaignId](map<string|string[]> headers = {}, *GetCampaignsIdQueries queries) returns Campaign1|error {
        string resourcePath = string `/campaigns/${getEncodedUri(campaignId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete campaign
    #
    # + campaignId - The unique id for the campaign
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete campaigns/[string campaignId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/campaigns/${getEncodedUri(campaignId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update campaign settings
    #
    # + campaignId - The unique id for the campaign
    # + headers - Headers to be sent with the request 
    resource isolated function patch campaigns/[string campaignId](Campaign2 payload, map<string|string[]> headers = {}) returns Campaign1|error {
        string resourcePath = string `/campaigns/${getEncodedUri(campaignId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # Cancel campaign
    #
    # + campaignId - The unique id for the campaign
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function post campaigns/[string campaignId]/actions/cancel\-send(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/campaigns/${getEncodedUri(campaignId)}/actions/cancel-send`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Replicate campaign
    #
    # + campaignId - The unique id for the campaign
    # + headers - Headers to be sent with the request 
    resource isolated function post campaigns/[string campaignId]/actions/replicate(map<string|string[]> headers = {}) returns Campaign3|error {
        string resourcePath = string `/campaigns/${getEncodedUri(campaignId)}/actions/replicate`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Send campaign
    #
    # + campaignId - The unique id for the campaign
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function post campaigns/[string campaignId]/actions/send(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/campaigns/${getEncodedUri(campaignId)}/actions/send`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Schedule campaign
    #
    # + campaignId - The unique id for the campaign
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function post campaigns/[string campaignId]/actions/schedule(ActionsScheduleBody payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/campaigns/${getEncodedUri(campaignId)}/actions/schedule`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Unschedule campaign
    #
    # + campaignId - The unique id for the campaign
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function post campaigns/[string campaignId]/actions/unschedule(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/campaigns/${getEncodedUri(campaignId)}/actions/unschedule`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Send test email
    #
    # + campaignId - The unique id for the campaign
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function post campaigns/[string campaignId]/actions/test(ActionsTestBody payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/campaigns/${getEncodedUri(campaignId)}/actions/test`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Pause rss campaign
    #
    # + campaignId - The unique id for the campaign
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function post campaigns/[string campaignId]/actions/pause(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/campaigns/${getEncodedUri(campaignId)}/actions/pause`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Resume rss campaign
    #
    # + campaignId - The unique id for the campaign
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function post campaigns/[string campaignId]/actions/resume(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/campaigns/${getEncodedUri(campaignId)}/actions/resume`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Resend campaign
    #
    # + campaignId - The unique id for the campaign
    # + headers - Headers to be sent with the request 
    resource isolated function post campaigns/[string campaignId]/actions/create\-resend(ActionsCreateResendBody payload, map<string|string[]> headers = {}) returns Campaign3|error {
        string resourcePath = string `/campaigns/${getEncodedUri(campaignId)}/actions/create-resend`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get campaign content
    #
    # + campaignId - The unique id for the campaign
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get campaigns/[string campaignId]/content(map<string|string[]> headers = {}, *GetCampaignsIdContentQueries queries) returns CampaignContent|error {
        string resourcePath = string `/campaigns/${getEncodedUri(campaignId)}/content`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Set campaign content
    #
    # + campaignId - The unique id for the campaign
    # + headers - Headers to be sent with the request 
    resource isolated function put campaigns/[string campaignId]/content(CampaignContent1 payload, map<string|string[]> headers = {}) returns CampaignContent|error {
        string resourcePath = string `/campaigns/${getEncodedUri(campaignId)}/content`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # List campaign feedback
    #
    # + campaignId - The unique id for the campaign
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get campaigns/[string campaignId]/feedback(map<string|string[]> headers = {}, *GetCampaignsIdFeedbackQueries queries) returns CampaignReports|error {
        string resourcePath = string `/campaigns/${getEncodedUri(campaignId)}/feedback`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add campaign feedback
    #
    # + campaignId - The unique id for the campaign
    # + headers - Headers to be sent with the request 
    resource isolated function post campaigns/[string campaignId]/feedback(CampaignFeedback payload, map<string|string[]> headers = {}) returns CampaignFeedback1|error {
        string resourcePath = string `/campaigns/${getEncodedUri(campaignId)}/feedback`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get campaign feedback message
    #
    # + campaignId - The unique id for the campaign
    # + feedbackId - The unique id for the feedback message
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get campaigns/[string campaignId]/feedback/[string feedbackId](map<string|string[]> headers = {}, *GetCampaignsIdFeedbackIdQueries queries) returns CampaignFeedback1|error {
        string resourcePath = string `/campaigns/${getEncodedUri(campaignId)}/feedback/${getEncodedUri(feedbackId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete campaign feedback message
    #
    # + campaignId - The unique id for the campaign
    # + feedbackId - The unique id for the feedback message
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete campaigns/[string campaignId]/feedback/[string feedbackId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/campaigns/${getEncodedUri(campaignId)}/feedback/${getEncodedUri(feedbackId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update campaign feedback message
    #
    # + campaignId - The unique id for the campaign
    # + feedbackId - The unique id for the feedback message
    # + headers - Headers to be sent with the request 
    resource isolated function patch campaigns/[string campaignId]/feedback/[string feedbackId](CampaignFeedback2 payload, map<string|string[]> headers = {}) returns CampaignFeedback1|error {
        string resourcePath = string `/campaigns/${getEncodedUri(campaignId)}/feedback/${getEncodedUri(feedbackId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # Get campaign send checklist
    #
    # + campaignId - The unique id for the campaign
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get campaigns/[string campaignId]/send\-checklist(map<string|string[]> headers = {}, *GetCampaignsIdSendChecklistQueries queries) returns SendChecklist|error {
        string resourcePath = string `/campaigns/${getEncodedUri(campaignId)}/send-checklist`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List connected sites
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get connected\-sites(map<string|string[]> headers = {}, *GetConnectedSitesQueries queries) returns ConnectedSites|error {
        string resourcePath = string `/connected-sites`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add connected site
    #
    # + headers - Headers to be sent with the request 
    resource isolated function post connected\-sites(ConnectedSite payload, map<string|string[]> headers = {}) returns ConnectedSite1|error {
        string resourcePath = string `/connected-sites`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get connected site
    #
    # + connectedSiteId - The unique identifier for the site
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get connected\-sites/[string connectedSiteId](map<string|string[]> headers = {}, *GetConnectedSitesIdQueries queries) returns ConnectedSite1|error {
        string resourcePath = string `/connected-sites/${getEncodedUri(connectedSiteId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete connected site
    #
    # + connectedSiteId - The unique identifier for the site
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete connected\-sites/[string connectedSiteId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/connected-sites/${getEncodedUri(connectedSiteId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Verify connected site script
    #
    # + connectedSiteId - The unique identifier for the site
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function post connected\-sites/[string connectedSiteId]/actions/verify\-script\-installation(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/connected-sites/${getEncodedUri(connectedSiteId)}/actions/verify-script-installation`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # List conversations
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # 
    # # Deprecated
    @deprecated
    resource isolated function get conversations(map<string|string[]> headers = {}, *GetConversationsQueries queries) returns TrackedConversations|error {
        string resourcePath = string `/conversations`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get conversation
    #
    # + conversationId - The unique id for the conversation
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # 
    # # Deprecated
    @deprecated
    resource isolated function get conversations/[string conversationId](map<string|string[]> headers = {}, *GetConversationsIdQueries queries) returns Conversation|error {
        string resourcePath = string `/conversations/${getEncodedUri(conversationId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List messages
    #
    # + conversationId - The unique id for the conversation
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # 
    # # Deprecated
    @deprecated
    resource isolated function get conversations/[string conversationId]/messages(map<string|string[]> headers = {}, *GetConversationsIdMessagesQueries queries) returns CollectionOfConversationMessages|error {
        string resourcePath = string `/conversations/${getEncodedUri(conversationId)}/messages`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get message
    #
    # + conversationId - The unique id for the conversation
    # + messageId - The unique id for the conversation message
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # 
    # # Deprecated
    @deprecated
    resource isolated function get conversations/[string conversationId]/messages/[string messageId](map<string|string[]> headers = {}, *GetConversationsIdMessagesIdQueries queries) returns ConversationMessage|error {
        string resourcePath = string `/conversations/${getEncodedUri(conversationId)}/messages/${getEncodedUri(messageId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Customer Journeys API trigger for a contact
    #
    # + journeyId - The id for the Journey
    # + stepId - The id for the Step
    # + headers - Headers to be sent with the request 
    # + return - An empty response 
    resource isolated function post customer\-journeys/journeys/[int journeyId]/steps/[int stepId]/actions/trigger(SubscriberInCustomerJourneysAudience payload, map<string|string[]> headers = {}) returns record {}|error {
        string resourcePath = string `/customer-journeys/journeys/${getEncodedUri(journeyId)}/steps/${getEncodedUri(stepId)}/actions/trigger`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # List stored files
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get file\-manager/files(map<string|string[]> headers = {}, *GetFileManagerFilesQueries queries) returns FileManager|error {
        string resourcePath = string `/file-manager/files`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add file
    #
    # + headers - Headers to be sent with the request 
    resource isolated function post file\-manager/files(GalleryFile payload, map<string|string[]> headers = {}) returns GalleryFile1|error {
        string resourcePath = string `/file-manager/files`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get file
    #
    # + fileId - The unique id for the File Manager file
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get file\-manager/files/[string fileId](map<string|string[]> headers = {}, *GetFileManagerFilesIdQueries queries) returns GalleryFile1|error {
        string resourcePath = string `/file-manager/files/${getEncodedUri(fileId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete file
    #
    # + fileId - The unique id for the File Manager file
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete file\-manager/files/[string fileId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/file-manager/files/${getEncodedUri(fileId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update file
    #
    # + fileId - The unique id for the File Manager file
    # + headers - Headers to be sent with the request 
    resource isolated function patch file\-manager/files/[string fileId](GalleryFile2 payload, map<string|string[]> headers = {}) returns GalleryFile1|error {
        string resourcePath = string `/file-manager/files/${getEncodedUri(fileId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # List folders
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get file\-manager/folders(map<string|string[]> headers = {}, *GetFileManagerFoldersQueries queries) returns FileManagerFolders|error {
        string resourcePath = string `/file-manager/folders`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add folder
    #
    # + headers - Headers to be sent with the request 
    resource isolated function post file\-manager/folders(GalleryFolder payload, map<string|string[]> headers = {}) returns GalleryFolder1|error {
        string resourcePath = string `/file-manager/folders`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get folder
    #
    # + folderId - The unique id for the File Manager folder
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get file\-manager/folders/[string folderId](map<string|string[]> headers = {}, *GetFileManagerFoldersIdQueries queries) returns GalleryFolder1|error {
        string resourcePath = string `/file-manager/folders/${getEncodedUri(folderId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete folder
    #
    # + folderId - The unique id for the File Manager folder
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete file\-manager/folders/[string folderId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/file-manager/folders/${getEncodedUri(folderId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update folder
    #
    # + folderId - The unique id for the File Manager folder
    # + headers - Headers to be sent with the request 
    resource isolated function patch file\-manager/folders/[string folderId](GalleryFolder payload, map<string|string[]> headers = {}) returns GalleryFolder1|error {
        string resourcePath = string `/file-manager/folders/${getEncodedUri(folderId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # List stored files
    #
    # + folderId - The unique id for the File Manager folder
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get file\-manager/folders/[string folderId]/files(map<string|string[]> headers = {}, *GetFileManagerFoldersFilesQueries queries) returns FileManager|error {
        string resourcePath = string `/file-manager/folders/${getEncodedUri(folderId)}/files`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get lists info
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get lists(map<string|string[]> headers = {}, *GetListsQueries queries) returns SubscriberLists|error {
        string resourcePath = string `/lists`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add list
    #
    # + headers - Headers to be sent with the request 
    resource isolated function post lists(SubscriberList payload, map<string|string[]> headers = {}) returns SubscriberList1|error {
        string resourcePath = string `/lists`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get list info
    #
    # + listId - The unique ID for the list
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get lists/[string listId](map<string|string[]> headers = {}, *GetListsIdQueries queries) returns SubscriberList1|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Batch subscribe or unsubscribe
    #
    # + listId - The unique ID for the list
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function post lists/[string listId](MembersToSubscribeUnsubscribeTofromAListInBatch payload, map<string|string[]> headers = {}, *PostListsIdQueries queries) returns BatchUpdateListMembers|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete list
    #
    # + listId - The unique ID for the list
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete lists/[string listId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/lists/${getEncodedUri(listId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update lists
    #
    # + listId - The unique ID for the list
    # + headers - Headers to be sent with the request 
    resource isolated function patch lists/[string listId](SubscriberList2 payload, map<string|string[]> headers = {}) returns SubscriberList1|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # List abuse reports
    #
    # + listId - The unique ID for the list
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get lists/[string listId]/abuse\-reports(map<string|string[]> headers = {}, *GetListsIdAbuseReportsQueries queries) returns AbuseComplaints|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/abuse-reports`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get merge field
    #
    # + listId - The unique ID for the list
    # + mergeId - The id for the merge field
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get lists/[string listId]/abuse\-reports/[string reportId](map<string|string[]> headers = {}, *GetListsIdAbuseReportsIdQueries queries) returns AbuseComplaint|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/abuse-reports/${getEncodedUri(reportId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List recent activity
    #
    # + listId - The unique ID for the list
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get lists/[string listId]/activity(map<string|string[]> headers = {}, *GetListsIdActivityQueries queries) returns ListActivity|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/activity`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List top email clients
    #
    # + listId - The unique ID for the list
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get lists/[string listId]/clients(map<string|string[]> headers = {}, *GetListsIdClientsQueries queries) returns EmailClients|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/clients`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List growth history data
    #
    # + listId - The unique ID for the list
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get lists/[string listId]/growth\-history(map<string|string[]> headers = {}, *GetListsIdGrowthHistoryQueries queries) returns GrowthHistory|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/growth-history`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get merge field
    #
    # + listId - The unique ID for the list
    # + mergeId - The id for the merge field
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get lists/[string listId]/growth\-history/[string month](map<string|string[]> headers = {}, *GetListsIdGrowthHistoryIdQueries queries) returns GrowthHistory1|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/growth-history/${getEncodedUri(month)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List interest categories
    #
    # + listId - The unique ID for the list
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get lists/[string listId]/interest\-categories(map<string|string[]> headers = {}, *GetListsIdInterestCategoriesQueries queries) returns InterestGroupings|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/interest-categories`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add interest category
    #
    # + listId - The unique ID for the list
    # + headers - Headers to be sent with the request 
    resource isolated function post lists/[string listId]/interest\-categories(InterestCategory payload, map<string|string[]> headers = {}) returns InterestCategory1|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/interest-categories`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get merge field
    #
    # + listId - The unique ID for the list
    # + mergeId - The id for the merge field
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get lists/[string listId]/interest\-categories/[string interestCategoryId](map<string|string[]> headers = {}, *GetListsIdInterestCategoriesIdQueries queries) returns InterestCategory1|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/interest-categories/${getEncodedUri(interestCategoryId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete merge field
    #
    # + listId - The unique ID for the list
    # + mergeId - The id for the merge field
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete lists/[string listId]/interest\-categories/[string interestCategoryId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/interest-categories/${getEncodedUri(interestCategoryId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update merge field
    #
    # + listId - The unique ID for the list
    # + mergeId - The id for the merge field
    # + headers - Headers to be sent with the request 
    resource isolated function patch lists/[string listId]/interest\-categories/[string interestCategoryId](InterestCategory payload, map<string|string[]> headers = {}) returns InterestCategory1|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/interest-categories/${getEncodedUri(interestCategoryId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # List interests in category
    #
    # + listId - The unique ID for the list
    # + interestCategoryId - The unique ID for the interest category
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get lists/[string listId]/interest\-categories/[string interestCategoryId]/interests(map<string|string[]> headers = {}, *GetListsIdInterestCategoriesIdInterestsQueries queries) returns Interests|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/interest-categories/${getEncodedUri(interestCategoryId)}/interests`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add interest in category
    #
    # + listId - The unique ID for the list
    # + interestCategoryId - The unique ID for the interest category
    # + headers - Headers to be sent with the request 
    resource isolated function post lists/[string listId]/interest\-categories/[string interestCategoryId]/interests(Interest payload, map<string|string[]> headers = {}) returns Interest1|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/interest-categories/${getEncodedUri(interestCategoryId)}/interests`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get interest in category
    #
    # + listId - The unique ID for the list
    # + interestCategoryId - The unique ID for the interest category
    # + interestId - The specific interest or 'group name'
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get lists/[string listId]/interest\-categories/[string interestCategoryId]/interests/[string interestId](map<string|string[]> headers = {}, *GetListsIdInterestCategoriesIdInterestsIdQueries queries) returns Interest1|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/interest-categories/${getEncodedUri(interestCategoryId)}/interests/${getEncodedUri(interestId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete interest in category
    #
    # + listId - The unique ID for the list
    # + interestCategoryId - The unique ID for the interest category
    # + interestId - The specific interest or 'group name'
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete lists/[string listId]/interest\-categories/[string interestCategoryId]/interests/[string interestId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/interest-categories/${getEncodedUri(interestCategoryId)}/interests/${getEncodedUri(interestId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update interest in category
    #
    # + listId - The unique ID for the list
    # + interestCategoryId - The unique ID for the interest category
    # + interestId - The specific interest or 'group name'
    # + headers - Headers to be sent with the request 
    resource isolated function patch lists/[string listId]/interest\-categories/[string interestCategoryId]/interests/[string interestId](Interest payload, map<string|string[]> headers = {}) returns Interest1|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/interest-categories/${getEncodedUri(interestCategoryId)}/interests/${getEncodedUri(interestId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # List segments
    #
    # + listId - The unique ID for the list
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get lists/[string listId]/segments(map<string|string[]> headers = {}, *PreviewASegmentQueries queries) returns CollectionOfSegments|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/segments`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add segment
    #
    # + listId - The unique ID for the list
    # + headers - Headers to be sent with the request 
    resource isolated function post lists/[string listId]/segments(List3 payload, map<string|string[]> headers = {}) returns List4|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/segments`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get segment info
    #
    # + listId - The unique ID for the list
    # + segmentId - The unique id for the segment
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get lists/[string listId]/segments/[string segmentId](map<string|string[]> headers = {}, *GetListsIdSegmentsIdQueries queries) returns List4|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/segments/${getEncodedUri(segmentId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Batch add or remove members
    #
    # + listId - The unique ID for the list
    # + segmentId - The unique id for the segment
    # + headers - Headers to be sent with the request 
    resource isolated function post lists/[string listId]/segments/[string segmentId](MembersToAddremoveTofromAStaticSegment payload, map<string|string[]> headers = {}) returns BatchAddremoveListMembersTofromStaticSegment|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/segments/${getEncodedUri(segmentId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Delete segment
    #
    # + listId - The unique ID for the list
    # + segmentId - The unique id for the segment
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete lists/[string listId]/segments/[string segmentId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/segments/${getEncodedUri(segmentId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update segment
    #
    # + listId - The unique ID for the list
    # + segmentId - The unique id for the segment
    # + headers - Headers to be sent with the request 
    resource isolated function patch lists/[string listId]/segments/[string segmentId](List5 payload, map<string|string[]> headers = {}) returns List4|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/segments/${getEncodedUri(segmentId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # List members in segment
    #
    # + listId - The unique ID for the list
    # + segmentId - The unique id for the segment
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get lists/[string listId]/segments/[string segmentId]/members(map<string|string[]> headers = {}, *GetListsIdSegmentsIdMembersQueries queries) returns SegmentMembers|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/segments/${getEncodedUri(segmentId)}/members`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add member to segment
    #
    # + listId - The unique ID for the list
    # + segmentId - The unique id for the segment
    # + headers - Headers to be sent with the request 
    resource isolated function post lists/[string listId]/segments/[string segmentId]/members(SegmentIdMembersBody payload, map<string|string[]> headers = {}) returns ListMembers|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/segments/${getEncodedUri(segmentId)}/members`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Remove list member from segment
    #
    # + listId - The unique ID for the list
    # + segmentId - The unique id for the segment
    # + subscriberHash - The MD5 hash of the lowercase version of the list member's email address
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete lists/[string listId]/segments/[string segmentId]/members/[string subscriberHash](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/segments/${getEncodedUri(segmentId)}/members/${getEncodedUri(subscriberHash)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Search for tags on a list by name.
    #
    # + listId - The unique ID for the list
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get lists/[string listId]/tag\-search(map<string|string[]> headers = {}, *SearchTagsByNameQueries queries) returns TagSearchResults|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/tag-search`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        return self.clientEp->get(resourcePath, headers);
    }

    # List members info
    #
    # + listId - The unique ID for the list
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get lists/[string listId]/members(map<string|string[]> headers = {}, *GetListsIdMembersQueries queries) returns ListMembers1|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/members`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add member to list
    #
    # + listId - The unique ID for the list
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function post lists/[string listId]/members(AddListMembers1 payload, map<string|string[]> headers = {}, *PostListsIdMembersQueries queries) returns ListMembers2|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/members`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get member info
    #
    # + listId - The unique ID for the list
    # + subscriberHash - The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get lists/[string listId]/members/[string subscriberHash](map<string|string[]> headers = {}, *GetListsIdMembersIdQueries queries) returns ListMembers2|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/members/${getEncodedUri(subscriberHash)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add or update list member
    #
    # + listId - The unique ID for the list
    # + subscriberHash - The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function put lists/[string listId]/members/[string subscriberHash](AddListMembers2 payload, map<string|string[]> headers = {}, *PutListsIdMembersIdQueries queries) returns ListMembers2|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/members/${getEncodedUri(subscriberHash)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Archive list member
    #
    # + listId - The unique ID for the list
    # + subscriberHash - The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete lists/[string listId]/members/[string subscriberHash](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/members/${getEncodedUri(subscriberHash)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update list member
    #
    # + listId - The unique ID for the list
    # + subscriberHash - The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function patch lists/[string listId]/members/[string subscriberHash](AddListMembers3 payload, map<string|string[]> headers = {}, *PatchListsIdMembersIdQueries queries) returns ListMembers2|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/members/${getEncodedUri(subscriberHash)}`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # View recent activity 50
    #
    # + listId - The unique ID for the list
    # + subscriberHash - The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get lists/[string listId]/members/[string subscriberHash]/activity(map<string|string[]> headers = {}, *GetListsIdMembersIdActivityQueries queries) returns MemberActivityEvents|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/members/${getEncodedUri(subscriberHash)}/activity`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}, "action": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # View recent activity
    #
    # + listId - The unique ID for the list
    # + subscriberHash - The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get lists/[string listId]/members/[string subscriberHash]/activity\-feed(map<string|string[]> headers = {}, *GetListsIdMembersIdActivityFeedQueries queries) returns MemberActivityEvents1|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/members/${getEncodedUri(subscriberHash)}/activity-feed`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}, "activity_filters": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List member tags
    #
    # + listId - The unique ID for the list
    # + subscriberHash - The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get lists/[string listId]/members/[string subscriberHash]/tags(map<string|string[]> headers = {}, *GetListMemberTagsQueries queries) returns CollectionOfTags|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/members/${getEncodedUri(subscriberHash)}/tags`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add or remove member tags
    #
    # + listId - The unique ID for the list
    # + subscriberHash - The MD5 hash of the lowercase version of the list member's email address
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function post lists/[string listId]/members/[string subscriberHash]/tags(MemberTags payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/members/${getEncodedUri(subscriberHash)}/tags`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # List member events
    #
    # + listId - The unique ID for the list
    # + subscriberHash - The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get lists/[string listId]/members/[string subscriberHash]/events(map<string|string[]> headers = {}, *GetListsIdMembersIdEventsQueries queries) returns CollectionOfEvents|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/members/${getEncodedUri(subscriberHash)}/events`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add event
    #
    # + listId - The unique ID for the list
    # + subscriberHash - The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function post lists/[string listId]/members/[string subscriberHash]/events(Events payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/members/${getEncodedUri(subscriberHash)}/events`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # List member goal events
    #
    # + listId - The unique ID for the list
    # + subscriberHash - The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get lists/[string listId]/members/[string subscriberHash]/goals(map<string|string[]> headers = {}, *GetListsIdMembersIdGoalsQueries queries) returns CollectionOfMemberActivityEvents|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/members/${getEncodedUri(subscriberHash)}/goals`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List recent member notes
    #
    # + listId - The unique ID for the list
    # + subscriberHash - The MD5 hash of the lowercase version of the list member's email address
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get lists/[string listId]/members/[string subscriberHash]/notes(map<string|string[]> headers = {}, *GetListsIdMembersIdNotesQueries queries) returns CollectionOfNotes|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/members/${getEncodedUri(subscriberHash)}/notes`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add member note
    #
    # + listId - The unique ID for the list
    # + subscriberHash - The MD5 hash of the lowercase version of the list member's email address
    # + headers - Headers to be sent with the request 
    resource isolated function post lists/[string listId]/members/[string subscriberHash]/notes(MemberNotes payload, map<string|string[]> headers = {}) returns MemberNotes1|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/members/${getEncodedUri(subscriberHash)}/notes`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get member note
    #
    # + listId - The unique ID for the list
    # + subscriberHash - The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id
    # + noteId - The id for the note
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get lists/[string listId]/members/[string subscriberHash]/notes/[string noteId](map<string|string[]> headers = {}, *GetListsIdMembersIdNotesIdQueries queries) returns MemberNotes1|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/members/${getEncodedUri(subscriberHash)}/notes/${getEncodedUri(noteId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete note
    #
    # + listId - The unique ID for the list
    # + subscriberHash - The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id
    # + noteId - The id for the note
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete lists/[string listId]/members/[string subscriberHash]/notes/[string noteId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/members/${getEncodedUri(subscriberHash)}/notes/${getEncodedUri(noteId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update note
    #
    # + listId - The unique ID for the list
    # + subscriberHash - The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id
    # + noteId - The id for the note
    # + headers - Headers to be sent with the request 
    resource isolated function patch lists/[string listId]/members/[string subscriberHash]/notes/[string noteId](MemberNotes payload, map<string|string[]> headers = {}) returns MemberNotes1|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/members/${getEncodedUri(subscriberHash)}/notes/${getEncodedUri(noteId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # Delete list member
    #
    # + listId - The unique ID for the list
    # + subscriberHash - The MD5 hash of the lowercase version of the list member's email address
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function post lists/[string listId]/members/[string subscriberHash]/actions/delete\-permanent(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/members/${getEncodedUri(subscriberHash)}/actions/delete-permanent`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # List merge fields
    #
    # + listId - The unique ID for the list
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get lists/[string listId]/merge\-fields(map<string|string[]> headers = {}, *GetListsIdMergeFieldsQueries queries) returns CollectionOfMergeFields|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/merge-fields`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add merge field
    #
    # + listId - The unique ID for the list
    # + headers - Headers to be sent with the request 
    resource isolated function post lists/[string listId]/merge\-fields(MergeField payload, map<string|string[]> headers = {}) returns MergeField1|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/merge-fields`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get merge field
    #
    # + listId - The unique ID for the list
    # + mergeId - The id for the merge field
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get lists/[string listId]/merge\-fields/[string mergeId](map<string|string[]> headers = {}, *GetListsIdMergeFieldsIdQueries queries) returns MergeField1|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/merge-fields/${getEncodedUri(mergeId)}`;
        map<Encoding> queryParamEncoding = {"exclude_fields": {style: FORM, explode: false}, "fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete merge field
    #
    # + listId - The unique ID for the list
    # + mergeId - The id for the merge field
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete lists/[string listId]/merge\-fields/[string mergeId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/merge-fields/${getEncodedUri(mergeId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update merge field
    #
    # + listId - The unique ID for the list
    # + mergeId - The id for the merge field
    # + headers - Headers to be sent with the request 
    resource isolated function patch lists/[string listId]/merge\-fields/[string mergeId](MergeField2 payload, map<string|string[]> headers = {}) returns MergeField1|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/merge-fields/${getEncodedUri(mergeId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # List webhooks
    #
    # + listId - The unique ID for the list
    # + headers - Headers to be sent with the request 
    resource isolated function get lists/[string listId]/webhooks(map<string|string[]> headers = {}) returns ListWebhooks|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/webhooks`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Add webhook
    #
    # + listId - The unique ID for the list
    # + headers - Headers to be sent with the request 
    resource isolated function post lists/[string listId]/webhooks(AddWebhook payload, map<string|string[]> headers = {}) returns ListWebhooks1|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/webhooks`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get webhook info
    #
    # + listId - The unique ID for the list
    # + webhookId - The webhook's id
    # + headers - Headers to be sent with the request 
    resource isolated function get lists/[string listId]/webhooks/[string webhookId](map<string|string[]> headers = {}) returns ListWebhooks1|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/webhooks/${getEncodedUri(webhookId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete webhook
    #
    # + listId - The unique ID for the list
    # + webhookId - The webhook's id
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete lists/[string listId]/webhooks/[string webhookId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/webhooks/${getEncodedUri(webhookId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update webhook
    #
    # + listId - The unique ID for the list
    # + webhookId - The webhook's id
    # + headers - Headers to be sent with the request 
    resource isolated function patch lists/[string listId]/webhooks/[string webhookId](AddWebhook payload, map<string|string[]> headers = {}) returns ListWebhooks1|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/webhooks/${getEncodedUri(webhookId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # List signup forms
    #
    # + listId - The unique ID for the list
    # + headers - Headers to be sent with the request 
    resource isolated function get lists/[string listId]/signup\-forms(map<string|string[]> headers = {}) returns ListSignupForms|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/signup-forms`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Customize signup form
    #
    # + listId - The unique ID for the list
    # + headers - Headers to be sent with the request 
    resource isolated function post lists/[string listId]/signup\-forms(SignupForm payload, map<string|string[]> headers = {}) returns SignupForm1|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/signup-forms`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # List locations
    #
    # + listId - The unique ID for the list
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get lists/[string listId]/locations(map<string|string[]> headers = {}, *GetListsIdLocationsQueries queries) returns ListLocations|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/locations`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get information about all surveys for a list
    #
    # + listId - The unique ID for the list
    # + headers - Headers to be sent with the request 
    resource isolated function get lists/[string listId]/surveys(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/surveys`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get survey
    #
    # + listId - The unique ID for the list
    # + surveyId - The ID of the survey
    # + headers - Headers to be sent with the request 
    resource isolated function get lists/[string listId]/surveys/[string surveyId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/surveys/${getEncodedUri(surveyId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Publish a Survey
    #
    # + listId - The unique ID for the list
    # + surveyId - The ID of the survey
    # + headers - Headers to be sent with the request 
    # + return - Survey Published 
    resource isolated function post lists/[string listId]/surveys/[string surveyId]/actions/publish(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/surveys/${getEncodedUri(surveyId)}/actions/publish`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Unpublish a Survey
    #
    # + listId - The unique ID for the list
    # + surveyId - The ID of the survey
    # + headers - Headers to be sent with the request 
    # + return - Survey Instance 
    resource isolated function post lists/[string listId]/surveys/[string surveyId]/actions/unpublish(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/surveys/${getEncodedUri(surveyId)}/actions/unpublish`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Create a Survey Campaign
    #
    # + listId - The unique ID for the list
    # + surveyId - The ID of the survey
    # + headers - Headers to be sent with the request 
    # + return - Campaign Instance 
    resource isolated function post lists/[string listId]/surveys/[string surveyId]/actions/create\-email(map<string|string[]> headers = {}) returns Campaign3|error {
        string resourcePath = string `/lists/${getEncodedUri(listId)}/surveys/${getEncodedUri(surveyId)}/actions/create-email`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # List landing pages
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Landing Pages Collection 
    resource isolated function get landing\-pages(map<string|string[]> headers = {}, *GetAllLandingPagesQueries queries) returns InlineResponse2008|error {
        string resourcePath = string `/landing-pages`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add landing page
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function post landing\-pages(LandingPage payload, map<string|string[]> headers = {}, *PostAllLandingPagesQueries queries) returns LandingPage1|error {
        string resourcePath = string `/landing-pages`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get landing page info
    #
    # + pageId - The unique id for the page
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Landing Pages Instance 
    resource isolated function get landing\-pages/[string pageId](map<string|string[]> headers = {}, *GetLandingPageIdQueries queries) returns LandingPage1|error {
        string resourcePath = string `/landing-pages/${getEncodedUri(pageId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete landing page
    #
    # + pageId - The unique id for the page
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete landing\-pages/[string pageId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/landing-pages/${getEncodedUri(pageId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update landing page
    #
    # + pageId - The unique id for the page
    # + headers - Headers to be sent with the request 
    resource isolated function patch landing\-pages/[string pageId](LandingPage2 payload, map<string|string[]> headers = {}) returns LandingPage1|error {
        string resourcePath = string `/landing-pages/${getEncodedUri(pageId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # Publish landing page
    #
    # + pageId - The unique id for the page
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function post landing\-pages/[string pageId]/actions/publish(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/landing-pages/${getEncodedUri(pageId)}/actions/publish`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Unpublish landing page
    #
    # + pageId - The unique id for the page
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function post landing\-pages/[string pageId]/actions/unpublish(map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/landing-pages/${getEncodedUri(pageId)}/actions/unpublish`;
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get landing page content
    #
    # + pageId - The unique id for the page
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get landing\-pages/[string pageId]/content(map<string|string[]> headers = {}, *GetLandingPageIdContentQueries queries) returns LandingPageContent|error {
        string resourcePath = string `/landing-pages/${getEncodedUri(pageId)}/content`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List campaign reports
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get reports(map<string|string[]> headers = {}, *GetReportsQueries queries) returns CampaignReports1|error {
        string resourcePath = string `/reports`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get campaign report
    #
    # + campaignId - The unique id for the campaign
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get reports/[string campaignId](map<string|string[]> headers = {}, *GetReportsIdQueries queries) returns CampaignReport|error {
        string resourcePath = string `/reports/${getEncodedUri(campaignId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List abuse reports
    #
    # + campaignId - The unique id for the campaign
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get reports/[string campaignId]/abuse\-reports(map<string|string[]> headers = {}, *GetReportsIdAbuseReportsIdQueries queries) returns AbuseComplaints1|error {
        string resourcePath = string `/reports/${getEncodedUri(campaignId)}/abuse-reports`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get campaign recipient info
    #
    # + campaignId - The unique id for the campaign
    # + subscriberHash - The MD5 hash of the lowercase version of the list member's email address
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get reports/[string campaignId]/abuse\-reports/[string reportId](map<string|string[]> headers = {}, *GetReportsIdAbuseReportsIdIdQueries queries) returns AbuseComplaint1|error {
        string resourcePath = string `/reports/${getEncodedUri(campaignId)}/abuse-reports/${getEncodedUri(reportId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List campaign feedback
    #
    # + campaignId - The unique id for the campaign
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get reports/[string campaignId]/advice(map<string|string[]> headers = {}, *GetReportsIdAdviceQueries queries) returns CampaignAdviceReport|error {
        string resourcePath = string `/reports/${getEncodedUri(campaignId)}/advice`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List campaign details
    #
    # + campaignId - The unique id for the campaign
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get reports/[string campaignId]/click\-details(map<string|string[]> headers = {}, *GetReportsIdClickDetailsQueries queries) returns ClickDetailReport|error {
        string resourcePath = string `/reports/${getEncodedUri(campaignId)}/click-details`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get campaign recipient info
    #
    # + campaignId - The unique id for the campaign
    # + subscriberHash - The MD5 hash of the lowercase version of the list member's email address
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get reports/[string campaignId]/click\-details/[string linkId](map<string|string[]> headers = {}, *GetReportsIdClickDetailsIdQueries queries) returns ClickDetailReport1|error {
        string resourcePath = string `/reports/${getEncodedUri(campaignId)}/click-details/${getEncodedUri(linkId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List clicked link subscribers
    #
    # + campaignId - The unique id for the campaign
    # + linkId - The id for the link
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get reports/[string campaignId]/click\-details/[string linkId]/members(map<string|string[]> headers = {}, *GetReportsIdClickDetailsIdMembersQueries queries) returns ClickDetailMembers|error {
        string resourcePath = string `/reports/${getEncodedUri(campaignId)}/click-details/${getEncodedUri(linkId)}/members`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get clicked link subscriber
    #
    # + campaignId - The unique id for the campaign
    # + linkId - The id for the link
    # + subscriberHash - The MD5 hash of the lowercase version of the list member's email address
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get reports/[string campaignId]/click\-details/[string linkId]/members/[string subscriberHash](map<string|string[]> headers = {}, *GetReportsIdClickDetailsIdMembersIdQueries queries) returns ClickDetailMember|error {
        string resourcePath = string `/reports/${getEncodedUri(campaignId)}/click-details/${getEncodedUri(linkId)}/members/${getEncodedUri(subscriberHash)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List campaign open details
    #
    # + campaignId - The unique id for the campaign
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get reports/[string campaignId]/open\-details(map<string|string[]> headers = {}, *GetReportsIdOpenDetailsQueries queries) returns OpenDetailReport|error {
        string resourcePath = string `/reports/${getEncodedUri(campaignId)}/open-details`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get campaign recipient info
    #
    # + campaignId - The unique id for the campaign
    # + subscriberHash - The MD5 hash of the lowercase version of the list member's email address
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get reports/[string campaignId]/open\-details/[string subscriberHash](map<string|string[]> headers = {}, *GetReportsIdOpenDetailsIdMembersIdQueries queries) returns OpenActivity|error {
        string resourcePath = string `/reports/${getEncodedUri(campaignId)}/open-details/${getEncodedUri(subscriberHash)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List domain performance stats
    #
    # + campaignId - The unique id for the campaign
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get reports/[string campaignId]/domain\-performance(map<string|string[]> headers = {}, *GetReportsIdDomainPerformanceQueries queries) returns DomainPerformance|error {
        string resourcePath = string `/reports/${getEncodedUri(campaignId)}/domain-performance`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List EepURL activity
    #
    # + campaignId - The unique id for the campaign
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get reports/[string campaignId]/eepurl(map<string|string[]> headers = {}, *GetReportsIdEepurlQueries queries) returns EepurlActivity|error {
        string resourcePath = string `/reports/${getEncodedUri(campaignId)}/eepurl`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List email activity
    #
    # + campaignId - The unique id for the campaign
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get reports/[string campaignId]/email\-activity(map<string|string[]> headers = {}, *GetReportsIdEmailActivityQueries queries) returns EmailActivity|error {
        string resourcePath = string `/reports/${getEncodedUri(campaignId)}/email-activity`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get campaign recipient info
    #
    # + campaignId - The unique id for the campaign
    # + subscriberHash - The MD5 hash of the lowercase version of the list member's email address
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get reports/[string campaignId]/email\-activity/[string subscriberHash](map<string|string[]> headers = {}, *GetReportsIdEmailActivityIdQueries queries) returns EmailActivity1|error {
        string resourcePath = string `/reports/${getEncodedUri(campaignId)}/email-activity/${getEncodedUri(subscriberHash)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List top open activities
    #
    # + campaignId - The unique id for the campaign
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get reports/[string campaignId]/locations(map<string|string[]> headers = {}, *GetReportsIdLocationsQueries queries) returns OpenLocations|error {
        string resourcePath = string `/reports/${getEncodedUri(campaignId)}/locations`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List campaign recipients
    #
    # + campaignId - The unique id for the campaign
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get reports/[string campaignId]/sent\-to(map<string|string[]> headers = {}, *GetReportsIdSentToQueries queries) returns SentTo|error {
        string resourcePath = string `/reports/${getEncodedUri(campaignId)}/sent-to`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get campaign recipient info
    #
    # + campaignId - The unique id for the campaign
    # + subscriberHash - The MD5 hash of the lowercase version of the list member's email address
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get reports/[string campaignId]/sent\-to/[string subscriberHash](map<string|string[]> headers = {}, *GetReportsIdSentToIdQueries queries) returns SentTo1|error {
        string resourcePath = string `/reports/${getEncodedUri(campaignId)}/sent-to/${getEncodedUri(subscriberHash)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List child campaign reports
    #
    # + campaignId - The unique id for the campaign
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get reports/[string campaignId]/sub\-reports(map<string|string[]> headers = {}, *GetReportsIdSubReportsIdQueries queries) returns CampaignSubReports|error {
        string resourcePath = string `/reports/${getEncodedUri(campaignId)}/sub-reports`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List unsubscribed members
    #
    # + campaignId - The unique id for the campaign
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get reports/[string campaignId]/unsubscribed(map<string|string[]> headers = {}, *GetReportsIdUnsubscribedQueries queries) returns Unsubscribes|error {
        string resourcePath = string `/reports/${getEncodedUri(campaignId)}/unsubscribed`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get unsubscribed member
    #
    # + campaignId - The unique id for the campaign
    # + subscriberHash - The MD5 hash of the lowercase version of the list member's email address
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get reports/[string campaignId]/unsubscribed/[string subscriberHash](map<string|string[]> headers = {}, *GetReportsIdUnsubscribedIdQueries queries) returns Unsubscribes1|error {
        string resourcePath = string `/reports/${getEncodedUri(campaignId)}/unsubscribed/${getEncodedUri(subscriberHash)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List campaign product activity
    #
    # + campaignId - The unique id for the campaign
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Ecommerce Product Activity Instance 
    resource isolated function get reports/[string campaignId]/ecommerce\-product\-activity(map<string|string[]> headers = {}, *GetReportsIdEcommerceProductActivityQueries queries) returns InlineResponse2009|error {
        string resourcePath = string `/reports/${getEncodedUri(campaignId)}/ecommerce-product-activity`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List templates
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get templates(map<string|string[]> headers = {}, *GetTemplatesQueries queries) returns Templates|error {
        string resourcePath = string `/templates`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add template
    #
    # + headers - Headers to be sent with the request 
    resource isolated function post templates(TemplateInstance payload, map<string|string[]> headers = {}) returns TemplateInstance1|error {
        string resourcePath = string `/templates`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get template info
    #
    # + templateId - The unique id for the template
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get templates/[string templateId](map<string|string[]> headers = {}, *GetTemplatesIdQueries queries) returns TemplateInstance1|error {
        string resourcePath = string `/templates/${getEncodedUri(templateId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete template
    #
    # + templateId - The unique id for the template
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete templates/[string templateId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/templates/${getEncodedUri(templateId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update template
    #
    # + templateId - The unique id for the template
    # + headers - Headers to be sent with the request 
    resource isolated function patch templates/[string templateId](TemplateInstance payload, map<string|string[]> headers = {}) returns TemplateInstance1|error {
        string resourcePath = string `/templates/${getEncodedUri(templateId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # View default content
    #
    # + templateId - The unique id for the template
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get templates/[string templateId]/default\-content(map<string|string[]> headers = {}, *GetTemplatesIdDefaultContentQueries queries) returns TemplateDefaultContent|error {
        string resourcePath = string `/templates/${getEncodedUri(templateId)}/default-content`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List account orders
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get ecommerce/orders(map<string|string[]> headers = {}, *GetEcommerceOrdersQueries queries) returns Orders|error {
        string resourcePath = string `/ecommerce/orders`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List stores
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get ecommerce/stores(map<string|string[]> headers = {}, *GetEcommerceStoresQueries queries) returns ECommerceStores|error {
        string resourcePath = string `/ecommerce/stores`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add store
    #
    # + headers - Headers to be sent with the request 
    resource isolated function post ecommerce/stores(ECommerceStore payload, map<string|string[]> headers = {}) returns ECommerceStore1|error {
        string resourcePath = string `/ecommerce/stores`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get store info
    #
    # + storeId - The store id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get ecommerce/stores/[string storeId](map<string|string[]> headers = {}, *GetEcommerceStoresIdQueries queries) returns ECommerceStore1|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete store
    #
    # + storeId - The store id
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete ecommerce/stores/[string storeId](map<string|string[]> headers = {}) returns record {}|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update store
    #
    # + storeId - The store id
    # + headers - Headers to be sent with the request 
    resource isolated function patch ecommerce/stores/[string storeId](ECommerceStore2 payload, map<string|string[]> headers = {}) returns ECommerceStore1|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # List carts
    #
    # + storeId - The store id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get ecommerce/stores/[string storeId]/carts(map<string|string[]> headers = {}, *GetEcommerceStoresIdCartsQueries queries) returns Carts|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/carts`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add cart
    #
    # + storeId - The store id
    # + headers - Headers to be sent with the request 
    resource isolated function post ecommerce/stores/[string storeId]/carts(ECommerceCart payload, map<string|string[]> headers = {}) returns ECommerceCart1|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/carts`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get cart info
    #
    # + storeId - The store id
    # + cartId - The id for the cart
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get ecommerce/stores/[string storeId]/carts/[string cartId](map<string|string[]> headers = {}, *GetEcommerceStoresIdCartsIdQueries queries) returns ECommerceCart1|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/carts/${getEncodedUri(cartId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete cart
    #
    # + storeId - The store id
    # + cartId - The id for the cart
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete ecommerce/stores/[string storeId]/carts/[string cartId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/carts/${getEncodedUri(cartId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update cart
    #
    # + storeId - The store id
    # + cartId - The id for the cart
    # + headers - Headers to be sent with the request 
    resource isolated function patch ecommerce/stores/[string storeId]/carts/[string cartId](ECommerceCart2 payload, map<string|string[]> headers = {}) returns ECommerceCart1|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/carts/${getEncodedUri(cartId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # List cart line items
    #
    # + storeId - The store id
    # + cartId - The id for the cart
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get ecommerce/stores/[string storeId]/carts/[string cartId]/lines(map<string|string[]> headers = {}, *GetEcommerceStoresIdCartsIdLinesQueries queries) returns CartLines|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/carts/${getEncodedUri(cartId)}/lines`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add cart line item
    #
    # + storeId - The store id
    # + cartId - The id for the cart
    # + headers - Headers to be sent with the request 
    resource isolated function post ecommerce/stores/[string storeId]/carts/[string cartId]/lines(ECommerceCartLineItem payload, map<string|string[]> headers = {}) returns ECommerceCartLineItem2|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/carts/${getEncodedUri(cartId)}/lines`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get cart line item
    #
    # + storeId - The store id
    # + cartId - The id for the cart
    # + lineId - The id for the line item of a cart
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get ecommerce/stores/[string storeId]/carts/[string cartId]/lines/[string lineId](map<string|string[]> headers = {}, *GetEcommerceStoresIdCartsIdLinesIdQueries queries) returns ECommerceCartLineItem2|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/carts/${getEncodedUri(cartId)}/lines/${getEncodedUri(lineId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete cart line item
    #
    # + storeId - The store id
    # + cartId - The id for the cart
    # + lineId - The id for the line item of a cart
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete ecommerce/stores/[string storeId]/carts/[string cartId]/lines/[string lineId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/carts/${getEncodedUri(cartId)}/lines/${getEncodedUri(lineId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update cart line item
    #
    # + storeId - The store id
    # + cartId - The id for the cart
    # + lineId - The id for the line item of a cart
    # + headers - Headers to be sent with the request 
    resource isolated function patch ecommerce/stores/[string storeId]/carts/[string cartId]/lines/[string lineId](ECommerceCartLineItem1 payload, map<string|string[]> headers = {}) returns ECommerceCartLineItem2|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/carts/${getEncodedUri(cartId)}/lines/${getEncodedUri(lineId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # List customers
    #
    # + storeId - The store id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get ecommerce/stores/[string storeId]/customers(map<string|string[]> headers = {}, *GetEcommerceStoresIdCustomersQueries queries) returns Customers|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/customers`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add customer
    #
    # + storeId - The store id
    # + headers - Headers to be sent with the request 
    resource isolated function post ecommerce/stores/[string storeId]/customers(ECommerceCustomer2 payload, map<string|string[]> headers = {}) returns ECommerceCustomer3|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/customers`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get customer info
    #
    # + storeId - The store id
    # + customerId - The id for the customer of a store
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get ecommerce/stores/[string storeId]/customers/[string customerId](map<string|string[]> headers = {}, *GetEcommerceStoresIdCustomersIdQueries queries) returns ECommerceCustomer3|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/customers/${getEncodedUri(customerId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add or update customer
    #
    # + storeId - The store id
    # + customerId - The id for the customer of a store
    # + headers - Headers to be sent with the request 
    resource isolated function put ecommerce/stores/[string storeId]/customers/[string customerId](ECommerceCustomer4 payload, map<string|string[]> headers = {}) returns ECommerceCustomer3|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/customers/${getEncodedUri(customerId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete customer
    #
    # + storeId - The store id
    # + customerId - The id for the customer of a store
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete ecommerce/stores/[string storeId]/customers/[string customerId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/customers/${getEncodedUri(customerId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update customer
    #
    # + storeId - The store id
    # + customerId - The id for the customer of a store
    # + headers - Headers to be sent with the request 
    resource isolated function patch ecommerce/stores/[string storeId]/customers/[string customerId](ECommerceCustomer1 payload, map<string|string[]> headers = {}) returns ECommerceCustomer3|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/customers/${getEncodedUri(customerId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # List promo rules
    #
    # + storeId - The store id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get ecommerce/stores/[string storeId]/promo\-rules(map<string|string[]> headers = {}, *GetEcommerceStoresIdPromorulesQueries queries) returns PromoRules|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/promo-rules`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add promo rule
    #
    # + storeId - The store id
    # + headers - Headers to be sent with the request 
    resource isolated function post ecommerce/stores/[string storeId]/promo\-rules(ECommercePromoRule payload, map<string|string[]> headers = {}) returns ECommercePromoRule1|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/promo-rules`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get promo rule
    #
    # + storeId - The store id
    # + promoRuleId - The id for the promo rule of a store
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get ecommerce/stores/[string storeId]/promo\-rules/[string promoRuleId](map<string|string[]> headers = {}, *GetEcommerceStoresIdPromorulesIdQueries queries) returns ECommercePromoRule1|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/promo-rules/${getEncodedUri(promoRuleId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete promo rule
    #
    # + storeId - The store id
    # + promoRuleId - The id for the promo rule of a store
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete ecommerce/stores/[string storeId]/promo\-rules/[string promoRuleId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/promo-rules/${getEncodedUri(promoRuleId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update promo rule
    #
    # + storeId - The store id
    # + promoRuleId - The id for the promo rule of a store
    # + headers - Headers to be sent with the request 
    resource isolated function patch ecommerce/stores/[string storeId]/promo\-rules/[string promoRuleId](ECommercePromoRule2 payload, map<string|string[]> headers = {}) returns ECommercePromoRule1|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/promo-rules/${getEncodedUri(promoRuleId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # List promo codes
    #
    # + promoRuleId - The id for the promo rule of a store
    # + storeId - The store id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get ecommerce/stores/[string storeId]/promo\-rules/[string promoRuleId]/promo\-codes(map<string|string[]> headers = {}, *GetEcommerceStoresIdPromocodesQueries queries) returns PromoCodes|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/promo-rules/${getEncodedUri(promoRuleId)}/promo-codes`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add promo code
    #
    # + storeId - The store id
    # + promoRuleId - The id for the promo rule of a store
    # + headers - Headers to be sent with the request 
    resource isolated function post ecommerce/stores/[string storeId]/promo\-rules/[string promoRuleId]/promo\-codes(ECommercePromoCode payload, map<string|string[]> headers = {}) returns ECommercePromoCode1|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/promo-rules/${getEncodedUri(promoRuleId)}/promo-codes`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get promo code
    #
    # + storeId - The store id
    # + promoRuleId - The id for the promo rule of a store
    # + promoCodeId - The id for the promo code of a store
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get ecommerce/stores/[string storeId]/promo\-rules/[string promoRuleId]/promo\-codes/[string promoCodeId](map<string|string[]> headers = {}, *GetEcommerceStoresIdPromocodesIdQueries queries) returns ECommercePromoCode1|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/promo-rules/${getEncodedUri(promoRuleId)}/promo-codes/${getEncodedUri(promoCodeId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete promo code
    #
    # + storeId - The store id
    # + promoRuleId - The id for the promo rule of a store
    # + promoCodeId - The id for the promo code of a store
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete ecommerce/stores/[string storeId]/promo\-rules/[string promoRuleId]/promo\-codes/[string promoCodeId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/promo-rules/${getEncodedUri(promoRuleId)}/promo-codes/${getEncodedUri(promoCodeId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update promo code
    #
    # + storeId - The store id
    # + promoRuleId - The id for the promo rule of a store
    # + promoCodeId - The id for the promo code of a store
    # + headers - Headers to be sent with the request 
    resource isolated function patch ecommerce/stores/[string storeId]/promo\-rules/[string promoRuleId]/promo\-codes/[string promoCodeId](ECommercePromoCode2 payload, map<string|string[]> headers = {}) returns ECommercePromoCode1|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/promo-rules/${getEncodedUri(promoRuleId)}/promo-codes/${getEncodedUri(promoCodeId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # List orders
    #
    # + storeId - The store id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get ecommerce/stores/[string storeId]/orders(map<string|string[]> headers = {}, *GetEcommerceStoresIdOrdersQueries queries) returns Orders1|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/orders`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add order
    #
    # + storeId - The store id
    # + headers - Headers to be sent with the request 
    resource isolated function post ecommerce/stores/[string storeId]/orders(ECommerceOrder payload, map<string|string[]> headers = {}) returns ECommerceOrder1|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/orders`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get order info
    #
    # + storeId - The store id
    # + orderId - The id for the order in a store
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get ecommerce/stores/[string storeId]/orders/[string orderId](map<string|string[]> headers = {}, *GetEcommerceStoresIdOrdersIdQueries queries) returns ECommerceOrder1|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/orders/${getEncodedUri(orderId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add or update order
    #
    # + storeId - The store id
    # + orderId - The id for the order in a store
    # + headers - Headers to be sent with the request 
    resource isolated function put ecommerce/stores/[string storeId]/orders/[string orderId](ECommerceOrder2 payload, map<string|string[]> headers = {}) returns ECommerceOrder1|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/orders/${getEncodedUri(orderId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete order
    #
    # + storeId - The store id
    # + orderId - The id for the order in a store
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete ecommerce/stores/[string storeId]/orders/[string orderId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/orders/${getEncodedUri(orderId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update order
    #
    # + storeId - The store id
    # + orderId - The id for the order in a store
    # + headers - Headers to be sent with the request 
    resource isolated function patch ecommerce/stores/[string storeId]/orders/[string orderId](ECommerceOrder3 payload, map<string|string[]> headers = {}) returns ECommerceOrder1|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/orders/${getEncodedUri(orderId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # List order line items
    #
    # + storeId - The store id
    # + orderId - The id for the order in a store
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get ecommerce/stores/[string storeId]/orders/[string orderId]/lines(map<string|string[]> headers = {}, *GetEcommerceStoresIdOrdersIdLinesQueries queries) returns OrderLines|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/orders/${getEncodedUri(orderId)}/lines`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add order line item
    #
    # + storeId - The store id
    # + orderId - The id for the order in a store
    # + headers - Headers to be sent with the request 
    resource isolated function post ecommerce/stores/[string storeId]/orders/[string orderId]/lines(ECommerceOrderLineItem payload, map<string|string[]> headers = {}) returns ECommerceOrderLineItem3|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/orders/${getEncodedUri(orderId)}/lines`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get order line item
    #
    # + storeId - The store id
    # + orderId - The id for the order in a store
    # + lineId - The id for the line item of an order
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get ecommerce/stores/[string storeId]/orders/[string orderId]/lines/[string lineId](map<string|string[]> headers = {}, *GetEcommerceStoresIdOrdersIdLinesIdQueries queries) returns ECommerceOrderLineItem3|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/orders/${getEncodedUri(orderId)}/lines/${getEncodedUri(lineId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete order line item
    #
    # + storeId - The store id
    # + orderId - The id for the order in a store
    # + lineId - The id for the line item of an order
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete ecommerce/stores/[string storeId]/orders/[string orderId]/lines/[string lineId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/orders/${getEncodedUri(orderId)}/lines/${getEncodedUri(lineId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update order line item
    #
    # + storeId - The store id
    # + orderId - The id for the order in a store
    # + lineId - The id for the line item of an order
    # + headers - Headers to be sent with the request 
    resource isolated function patch ecommerce/stores/[string storeId]/orders/[string orderId]/lines/[string lineId](ECommerceOrderLineItem2 payload, map<string|string[]> headers = {}) returns ECommerceOrderLineItem3|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/orders/${getEncodedUri(orderId)}/lines/${getEncodedUri(lineId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # List product
    #
    # + storeId - The store id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get ecommerce/stores/[string storeId]/products(map<string|string[]> headers = {}, *GetEcommerceStoresIdProductsQueries queries) returns Products|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/products`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add product
    #
    # + storeId - The store id
    # + headers - Headers to be sent with the request 
    resource isolated function post ecommerce/stores/[string storeId]/products(ECommerceProduct payload, map<string|string[]> headers = {}) returns ECommerceProduct2|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/products`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get product info
    #
    # + storeId - The store id
    # + productId - The id for the product of a store
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get ecommerce/stores/[string storeId]/products/[string productId](map<string|string[]> headers = {}, *GetEcommerceStoresIdProductsIdQueries queries) returns ECommerceProduct2|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/products/${getEncodedUri(productId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Create or update product
    #
    # + storeId - The store id
    # + productId - The id for the product of a store
    # + headers - Headers to be sent with the request 
    resource isolated function put ecommerce/stores/[string storeId]/products/[string productId](ECommerceProduct1 payload, map<string|string[]> headers = {}) returns ECommerceProduct2|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/products/${getEncodedUri(productId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete product
    #
    # + storeId - The store id
    # + productId - The id for the product of a store
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete ecommerce/stores/[string storeId]/products/[string productId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/products/${getEncodedUri(productId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update product
    #
    # + storeId - The store id
    # + productId - The id for the product of a store
    # + headers - Headers to be sent with the request 
    resource isolated function patch ecommerce/stores/[string storeId]/products/[string productId](ECommerceProduct3 payload, map<string|string[]> headers = {}) returns ECommerceProduct2|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/products/${getEncodedUri(productId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # List product variants
    #
    # + storeId - The store id
    # + productId - The id for the product of a store
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get ecommerce/stores/[string storeId]/products/[string productId]/variants(map<string|string[]> headers = {}, *GetEcommerceStoresIdProductsIdVariantsQueries queries) returns EcommerceProductVariants|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/products/${getEncodedUri(productId)}/variants`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add product variant
    #
    # + storeId - The store id
    # + productId - The id for the product of a store
    # + headers - Headers to be sent with the request 
    resource isolated function post ecommerce/stores/[string storeId]/products/[string productId]/variants(ECommerceProductVariant payload, map<string|string[]> headers = {}) returns ECommerceProductVariant2|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/products/${getEncodedUri(productId)}/variants`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get product variant info
    #
    # + storeId - The store id
    # + productId - The id for the product of a store
    # + variantId - The id for the product variant
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get ecommerce/stores/[string storeId]/products/[string productId]/variants/[string variantId](map<string|string[]> headers = {}, *GetEcommerceStoresIdProductsIdVariantsIdQueries queries) returns ECommerceProductVariant2|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/products/${getEncodedUri(productId)}/variants/${getEncodedUri(variantId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add or update product variant
    #
    # + storeId - The store id
    # + productId - The id for the product of a store
    # + variantId - The id for the product variant
    # + headers - Headers to be sent with the request 
    resource isolated function put ecommerce/stores/[string storeId]/products/[string productId]/variants/[string variantId](ECommerceProductVariant payload, map<string|string[]> headers = {}) returns ECommerceProductVariant2|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/products/${getEncodedUri(productId)}/variants/${getEncodedUri(variantId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete product variant
    #
    # + storeId - The store id
    # + productId - The id for the product of a store
    # + variantId - The id for the product variant
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete ecommerce/stores/[string storeId]/products/[string productId]/variants/[string variantId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/products/${getEncodedUri(productId)}/variants/${getEncodedUri(variantId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update product variant
    #
    # + storeId - The store id
    # + productId - The id for the product of a store
    # + variantId - The id for the product variant
    # + headers - Headers to be sent with the request 
    resource isolated function patch ecommerce/stores/[string storeId]/products/[string productId]/variants/[string variantId](ECommerceProductVariant1 payload, map<string|string[]> headers = {}) returns ECommerceProductVariant2|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/products/${getEncodedUri(productId)}/variants/${getEncodedUri(variantId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # List product images
    #
    # + storeId - The store id
    # + productId - The id for the product of a store
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get ecommerce/stores/[string storeId]/products/[string productId]/images(map<string|string[]> headers = {}, *GetEcommerceStoresIdProductsIdImagesQueries queries) returns EcommerceProductImages|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/products/${getEncodedUri(productId)}/images`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add product image
    #
    # + storeId - The store id
    # + productId - The id for the product of a store
    # + headers - Headers to be sent with the request 
    resource isolated function post ecommerce/stores/[string storeId]/products/[string productId]/images(ECommerceProductImage payload, map<string|string[]> headers = {}) returns ECommerceProductImage2|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/products/${getEncodedUri(productId)}/images`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get product image info
    #
    # + storeId - The store id
    # + productId - The id for the product of a store
    # + imageId - The id for the product image
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get ecommerce/stores/[string storeId]/products/[string productId]/images/[string imageId](map<string|string[]> headers = {}, *GetEcommerceStoresIdProductsIdImagesIdQueries queries) returns ECommerceProductImage2|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/products/${getEncodedUri(productId)}/images/${getEncodedUri(imageId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete product image
    #
    # + storeId - The store id
    # + productId - The id for the product of a store
    # + imageId - The id for the product image
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete ecommerce/stores/[string storeId]/products/[string productId]/images/[string imageId](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/products/${getEncodedUri(productId)}/images/${getEncodedUri(imageId)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Update product image
    #
    # + storeId - The store id
    # + productId - The id for the product of a store
    # + imageId - The id for the product image
    # + headers - Headers to be sent with the request 
    resource isolated function patch ecommerce/stores/[string storeId]/products/[string productId]/images/[string imageId](ECommerceProductImage1 payload, map<string|string[]> headers = {}) returns ECommerceProductImage2|error {
        string resourcePath = string `/ecommerce/stores/${getEncodedUri(storeId)}/products/${getEncodedUri(productId)}/images/${getEncodedUri(imageId)}`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->patch(resourcePath, request, headers);
    }

    # Search campaigns
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get search\-campaigns(map<string|string[]> headers = {}, *GetSearchCampaignsQueries queries) returns Campaigns|error {
        string resourcePath = string `/search-campaigns`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Search members
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    resource isolated function get search\-members(map<string|string[]> headers = {}, *GetSearchMembersQueries queries) returns Members|error {
        string resourcePath = string `/search-members`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Ping
    #
    # + headers - Headers to be sent with the request 
    resource isolated function get ping(map<string|string[]> headers = {}) returns APIHealthStatus|error {
        string resourcePath = string `/ping`;
        return self.clientEp->get(resourcePath, headers);
    }

    # List facebook ads
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - List of Facebook Ad Instances 
    resource isolated function get facebook\-ads(map<string|string[]> headers = {}, *GetAllFacebookAdsQueries queries) returns InlineResponse20010|error {
        string resourcePath = string `/facebook-ads`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get facebook ad info
    #
    # + outreachId - The outreach id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Facebook Ad Instance 
    resource isolated function get facebook\-ads/[string outreachId](map<string|string[]> headers = {}, *GetFacebookAdsIdQueries queries) returns InlineResponse20011|error {
        string resourcePath = string `/facebook-ads/${getEncodedUri(outreachId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List facebook ads reports
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - List of Facebook Ad Report Instances 
    resource isolated function get reporting/facebook\-ads(map<string|string[]> headers = {}, *GetReportingFacebookAdsQueries queries) returns InlineResponse20012|error {
        string resourcePath = string `/reporting/facebook-ads`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get landing page report
    #
    # + outreachId - The outreach id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Landing Page Report Instance 
    resource isolated function get reporting/facebook\-ads/[string outreachId](map<string|string[]> headers = {}, *GetReportingFacebookAdsIdQueries queries) returns InlineResponse20013|error {
        string resourcePath = string `/reporting/facebook-ads/${getEncodedUri(outreachId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List facebook ecommerce report
    #
    # + outreachId - The outreach id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Ecommerce Product Activity Instance 
    resource isolated function get reporting/facebook\-ads/[string outreachId]/ecommerce\-product\-activity(map<string|string[]> headers = {}, *GetReportingFacebookAdsIdEcommerceProductActivityQueries queries) returns InlineResponse2009|error {
        string resourcePath = string `/reporting/facebook-ads/${getEncodedUri(outreachId)}/ecommerce-product-activity`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get landing page report
    #
    # + outreachId - The outreach id
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Landing Page Report Instance 
    resource isolated function get reporting/landing\-pages/[string outreachId](map<string|string[]> headers = {}, *GetReportingLandingPagesIdQueries queries) returns LandingPageReport|error {
        string resourcePath = string `/reporting/landing-pages/${getEncodedUri(outreachId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List landing pages reports
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - List of Landing Page Report Instances 
    resource isolated function get reporting/landing\-pages(map<string|string[]> headers = {}, *GetReportingLandingPagesQueries queries) returns InlineResponse20014|error {
        string resourcePath = string `/reporting/landing-pages`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List survey reports
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - List of Survey Report Instances 
    resource isolated function get reporting/surveys(map<string|string[]> headers = {}, *GetReportingSurveysQueries queries) returns InlineResponse20015|error {
        string resourcePath = string `/reporting/surveys`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get survey report
    #
    # + surveyId - The ID of the survey
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Survey Report Instance 
    resource isolated function get reporting/surveys/[string surveyId](map<string|string[]> headers = {}, *GetReportingSurveysIdQueries queries) returns SurveyReport|error {
        string resourcePath = string `/reporting/surveys/${getEncodedUri(surveyId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List survey question reports
    #
    # + surveyId - The ID of the survey
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - List of Survey Question Report Instances 
    resource isolated function get reporting/surveys/[string surveyId]/questions(map<string|string[]> headers = {}, *GetReportingSurveysIdQuestionsQueries queries) returns InlineResponse20016|error {
        string resourcePath = string `/reporting/surveys/${getEncodedUri(surveyId)}/questions`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get survey question report
    #
    # + surveyId - The ID of the survey
    # + questionId - The ID of the survey question
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Survey Question Report Instance 
    resource isolated function get reporting/surveys/[string surveyId]/questions/[string questionId](map<string|string[]> headers = {}, *GetReportingSurveysIdQuestionsIdQueries queries) returns SurveyQuestionReport|error {
        string resourcePath = string `/reporting/surveys/${getEncodedUri(surveyId)}/questions/${getEncodedUri(questionId)}`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List answers for question
    #
    # + surveyId - The ID of the survey
    # + questionId - The ID of the survey question
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - List of Survey Question Answers 
    resource isolated function get reporting/surveys/[string surveyId]/questions/[string questionId]/answers(map<string|string[]> headers = {}, *GetReportingSurveysIdQuestionsIdAnswersQueries queries) returns InlineResponse20017|error {
        string resourcePath = string `/reporting/surveys/${getEncodedUri(surveyId)}/questions/${getEncodedUri(questionId)}/answers`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # List survey responses
    #
    # + surveyId - The ID of the survey
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - List of survey responses 
    resource isolated function get reporting/surveys/[string surveyId]/responses(map<string|string[]> headers = {}, *GetReportingSurveysIdResponsesQueries queries) returns InlineResponse20018|error {
        string resourcePath = string `/reporting/surveys/${getEncodedUri(surveyId)}/responses`;
        map<Encoding> queryParamEncoding = {"fields": {style: FORM, explode: false}, "exclude_fields": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get survey response
    #
    # + surveyId - The ID of the survey
    # + responseId - The ID of the survey response
    # + headers - Headers to be sent with the request 
    # + return - Get a single survey response 
    resource isolated function get reporting/surveys/[string surveyId]/responses/[string responseId](map<string|string[]> headers = {}) returns SurveyResponse|error {
        string resourcePath = string `/reporting/surveys/${getEncodedUri(surveyId)}/responses/${getEncodedUri(responseId)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Get domain info
    #
    # + domainName - The domain name
    # + headers - Headers to be sent with the request 
    resource isolated function get verified\-domains/[string domainName](map<string|string[]> headers = {}) returns VerifiedDomains|error {
        string resourcePath = string `/verified-domains/${getEncodedUri(domainName)}`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete domain
    #
    # + domainName - The domain name
    # + headers - Headers to be sent with the request 
    # + return - Empty Response 
    resource isolated function delete verified\-domains/[string domainName](map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/verified-domains/${getEncodedUri(domainName)}`;
        return self.clientEp->delete(resourcePath, headers = headers);
    }

    # Verify domain
    #
    # + domainName - The domain name
    # + headers - Headers to be sent with the request 
    # + return - The domain being verified for sending 
    resource isolated function post verified\-domains/[string domainName]/actions/verify(VerifyADomainForSending payload, map<string|string[]> headers = {}) returns VerifiedDomains|error {
        string resourcePath = string `/verified-domains/${getEncodedUri(domainName)}/actions/verify`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # List sending domains
    #
    # + headers - Headers to be sent with the request 
    # + return - The domains on the account 
    resource isolated function get verified\-domains(map<string|string[]> headers = {}) returns VerifiedDomains1|error {
        string resourcePath = string `/verified-domains`;
        return self.clientEp->get(resourcePath, headers);
    }

    # Add domain to account
    #
    # + headers - Headers to be sent with the request 
    # + return - The newly-created domain 
    resource isolated function post verified\-domains(VerifiedDomains2 payload, map<string|string[]> headers = {}) returns VerifiedDomains|error {
        string resourcePath = string `/verified-domains`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }
}
